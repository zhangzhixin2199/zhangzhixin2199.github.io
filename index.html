<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jason Zhang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason Zhang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jason Zhang">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jason Zhang">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Jason Zhang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jason Zhang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-引入Fresco前调研报告" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/27/引入Fresco前调研报告/" class="article-date">
  <time datetime="2016-03-27T13:26:59.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/27/引入Fresco前调研报告/">引入Fresco前的调研报告</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="结合目前较为流行的图片库，选择Fresco的原因："><a href="#结合目前较为流行的图片库，选择Fresco的原因：" class="headerlink" title="结合目前较为流行的图片库，选择Fresco的原因："></a>结合目前较为流行的图片库，选择Fresco的原因：</h2><h3 id="1、Fresco最小版本支持到android-API-9-，Gilde-最小版本支持到10；"><a href="#1、Fresco最小版本支持到android-API-9-，Gilde-最小版本支持到10；" class="headerlink" title="1、Fresco最小版本支持到android API 9 ，Gilde 最小版本支持到10；"></a>1、Fresco最小版本支持到android API 9 ，Gilde 最小版本支持到10；</h3><h3 id="2、使用简单，"><a href="#2、使用简单，" class="headerlink" title="2、使用简单，"></a>2、使用简单，</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SimpleDraweeView mBaselineJpegView = (SimpleDraweeView) findViewById(R.id.baseline_jpeg);</span><br><span class="line"> Uri uri2 = new Uri.Builder()</span><br><span class="line">         .scheme(UriUtil.LOCAL_RESOURCE_SCHEME) // <span class="string">"res"</span></span><br><span class="line"> .path(String.valueOf(R.drawable.discover_sns))</span><br><span class="line">         .build();</span><br><span class="line"> mBaselineJpegView.setImageURI(uri2);`</span><br></pre></td></tr></table></figure>
<p> 支持布局文件xml设置属性，占位图、加载动画、缩放比例、圆角和圆形设置等；<br> 特别注意：Fresco 不支持 相对路径的URI. 所有的URI都必须是绝对路径，并且带上该URI的scheme。</p>
<p> 如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">Scheme</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>远程图片</td>
<td style="text-align:center"><a href="http://,https://" target="_blank" rel="external">http://,https://</a></td>
<td>HttpURLConnection 或者参考 使用其他网络加载方案</td>
<td></td>
</tr>
<tr>
<td>本地文件</td>
<td style="text-align:center">file://</td>
<td>FileInputStream</td>
</tr>
<tr>
<td>Content provider</td>
<td style="text-align:center">content://</td>
<td>ContentResolver</td>
</tr>
<tr>
<td>asset目录下的资源</td>
<td style="text-align:center">asset://</td>
<td>AssetManager</td>
</tr>
<tr>
<td>res目录下的资源</td>
<td style="text-align:center">res://</td>
<td>Resources.openRawResource</td>
</tr>
</tbody>
</table>
<h3 id="3、5-0以下系统：图片不存储在Java-heap，而是存储在ashmem，中间的字节-buffer同样位于native-heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关-于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆-内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5-0以上系统，由于内存管理的优化，所以对于5-0以上的系统-Fresco将Bitmap缓存直接放到了堆内存中。"><a href="#3、5-0以下系统：图片不存储在Java-heap，而是存储在ashmem，中间的字节-buffer同样位于native-heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关-于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆-内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5-0以上系统，由于内存管理的优化，所以对于5-0以上的系统-Fresco将Bitmap缓存直接放到了堆内存中。" class="headerlink" title="3、5.0以下系统：图片不存储在Java heap，而是存储在ashmem，中间的字节 buffer同样位于native heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关 于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆 内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5.0以上系统，由于内存管理的优化，所以对于5.0以上的系统 Fresco将Bitmap缓存直接放到了堆内存中。"></a>3、5.0以下系统：图片不存储在Java heap，而是存储在ashmem，中间的字节 buffer同样位于native heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关 于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆 内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5.0以上系统，由于内存管理的优化，所以对于5.0以上的系统 Fresco将Bitmap缓存直接放到了堆内存中。</h3><h3 id="关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种-为”Purgeable-Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory-Options中有这么一个属性inPurgeable："><a href="#关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种-为”Purgeable-Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory-Options中有这么一个属性inPurgeable：" class="headerlink" title="关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种 为”Purgeable Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory.Options中有这么一个属性inPurgeable："></a>关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种 为”Purgeable Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory.Options中有这么一个属性inPurgeable：</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options = new BitmapFactory.Options();</span><br><span class="line">options.inPurgeable = <span class="literal">true</span>;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);</span><br></pre></td></tr></table></figure>
<h3 id="所以通过配置inPurgeable-true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。"><a href="#所以通过配置inPurgeable-true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。" class="headerlink" title="所以通过配置inPurgeable = true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。"></a>所以通过配置inPurgeable = true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。</h3><h3 id="既然Fresco中Bitmap缓存在5-0以前是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收-它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个-SharedReference这个类，这个类中有这么两个方法：addReference-和deleteReference-，通过这两个基本方-法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap-recycle-等），而Fresco为了考虑更容易被我们使用，又提-供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同-时也实现了Cloneable、Closeable接口，它在调用-clone-方法时同时会调用addReference-来增加一个引用计数，在-调用-close-方法时同时会调用deleteReference-来删除一个引用计数，所以在使用Fresco的使用，我们都是与-CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则："><a href="#既然Fresco中Bitmap缓存在5-0以前是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收-它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个-SharedReference这个类，这个类中有这么两个方法：addReference-和deleteReference-，通过这两个基本方-法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap-recycle-等），而Fresco为了考虑更容易被我们使用，又提-供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同-时也实现了Cloneable、Closeable接口，它在调用-clone-方法时同时会调用addReference-来增加一个引用计数，在-调用-close-方法时同时会调用deleteReference-来删除一个引用计数，所以在使用Fresco的使用，我们都是与-CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则：" class="headerlink" title="既然Fresco中Bitmap缓存在5.0以前是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收 它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个 SharedReference这个类，这个类中有这么两个方法：addReference()和deleteReference()，通过这两个基本方 法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap.recycle()等），而Fresco为了考虑更容易被我们使用，又提 供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同 时也实现了Cloneable、Closeable接口，它在调用.clone()方法时同时会调用addReference()来增加一个引用计数，在 调用.close()方法时同时会调用deleteReference()来删除一个引用计数，所以在使用Fresco的使用，我们都是与 CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则："></a>既然Fresco中Bitmap缓存在5.0以前是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收 它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个 SharedReference这个类，这个类中有这么两个方法：addReference()和deleteReference()，通过这两个基本方 法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap.recycle()等），而Fresco为了考虑更容易被我们使用，又提 供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同 时也实现了Cloneable、Closeable接口，它在调用.clone()方法时同时会调用addReference()来增加一个引用计数，在 调用.close()方法时同时会调用deleteReference()来删除一个引用计数，所以在使用Fresco的使用，我们都是与 CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则：</h3><h4 id="1）、在赋值CloseableReference给新对象的时候，调用-clone-进行赋值"><a href="#1）、在赋值CloseableReference给新对象的时候，调用-clone-进行赋值" class="headerlink" title="1）、在赋值CloseableReference给新对象的时候，调用.clone()进行赋值"></a>1）、在赋值CloseableReference给新对象的时候，调用.clone()进行赋值</h4><h4 id="2）、在超出作用域范围的时候，必须调用-close-，通常会在finally代码块中调用"><a href="#2）、在超出作用域范围的时候，必须调用-close-，通常会在finally代码块中调用" class="headerlink" title="2）、在超出作用域范围的时候，必须调用.close()，通常会在finally代码块中调用"></a>2）、在超出作用域范围的时候，必须调用.close()，通常会在finally代码块中调用</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">gee</span></span>() &#123;</span><br><span class="line">  CloseableReference&lt;Value&gt; ref = foo();</span><br><span class="line">  try &#123;</span><br><span class="line">    haa(ref);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ref.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遵循这些规则可以有效地防止内存泄漏。"><a href="#遵循这些规则可以有效地防止内存泄漏。" class="headerlink" title="遵循这些规则可以有效地防止内存泄漏。"></a>遵循这些规则可以有效地防止内存泄漏。</h3><h3 id="4、目前支持目前大部分图片格式：png、jpg-jpeg、gif、webP，jpeg图片的渐进式呈现，webp格式是Google官方推行的，它的大小比其它格式图片的大小要小一半左右，目前各个大公司都渐入的使用这种图片格式了，-使用该格式最大的优点就是轻量、省流量、图片加载迅速。而Fresco是通过jni来实现-支持WebP格式图片；"><a href="#4、目前支持目前大部分图片格式：png、jpg-jpeg、gif、webP，jpeg图片的渐进式呈现，webp格式是Google官方推行的，它的大小比其它格式图片的大小要小一半左右，目前各个大公司都渐入的使用这种图片格式了，-使用该格式最大的优点就是轻量、省流量、图片加载迅速。而Fresco是通过jni来实现-支持WebP格式图片；" class="headerlink" title="4、目前支持目前大部分图片格式：png、jpg/jpeg、gif、webP，jpeg图片的渐进式呈现，webp格式是Google官方推行的，它的大小比其它格式图片的大小要小一半左右，目前各个大公司都渐入的使用这种图片格式了， 使用该格式最大的优点就是轻量、省流量、图片加载迅速。而Fresco是通过jni来实现 支持WebP格式图片；"></a>4、目前支持目前大部分图片格式：png、jpg/jpeg、gif、webP，jpeg图片的渐进式呈现，webp格式是Google官方推行的，它的大小比其它格式图片的大小要小一半左右，目前各个大公司都渐入的使用这种图片格式了， 使用该格式最大的优点就是轻量、省流量、图片加载迅速。而Fresco是通过jni来实现 支持WebP格式图片；</h3><h3 id="5、支持集成okHttp、Volley；"><a href="#5、支持集成okHttp、Volley；" class="headerlink" title="5、支持集成okHttp、Volley；"></a>5、支持集成okHttp、Volley；</h3><h3 id="6、Fresco是一个MVC模型，由三大组件构成，它们的对应关系如下所示："><a href="#6、Fresco是一个MVC模型，由三大组件构成，它们的对应关系如下所示：" class="headerlink" title="6、Fresco是一个MVC模型，由三大组件构成，它们的对应关系如下所示："></a>6、Fresco是一个MVC模型，由三大组件构成，它们的对应关系如下所示：</h3><h3 id="M-gt-DraweeHierarchy-V-gt-DraweeView-C-gt-DraweeController"><a href="#M-gt-DraweeHierarchy-V-gt-DraweeView-C-gt-DraweeController" class="headerlink" title="M -&gt; DraweeHierarchy V -&gt; DraweeView C -&gt; DraweeController"></a>M -&gt; DraweeHierarchy V -&gt; DraweeView C -&gt; DraweeController</h3><h3 id="M-所对应的-DraweeHierarchy-是一个有层次结构的数据结构，DraweeView-用来显示位于-DraweeHierarchy-最顶层的图像（top-level-drawable），DraweeController-则用来控制-DraweeHierarchy-的顶层图像是哪一个。"><a href="#M-所对应的-DraweeHierarchy-是一个有层次结构的数据结构，DraweeView-用来显示位于-DraweeHierarchy-最顶层的图像（top-level-drawable），DraweeController-则用来控制-DraweeHierarchy-的顶层图像是哪一个。" class="headerlink" title="M 所对应的 DraweeHierarchy 是一个有层次结构的数据结构，DraweeView 用来显示位于 DraweeHierarchy 最顶层的图像（top level drawable），DraweeController 则用来控制 DraweeHierarchy 的顶层图像是哪一个。"></a>M 所对应的 DraweeHierarchy 是一个有层次结构的数据结构，DraweeView 用来显示位于 DraweeHierarchy 最顶层的图像（top level drawable），DraweeController 则用来控制 DraweeHierarchy 的顶层图像是哪一个。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">o FadeDrawable (top level drawable)</span><br><span class="line">|</span><br><span class="line">+--o ScaleTypeDrawable</span><br><span class="line">|  |</span><br><span class="line">|  +--o BitmapDrawable</span><br><span class="line">|</span><br><span class="line">+--o ScaleTypeDrawable</span><br><span class="line">   |</span><br><span class="line">   +--o BitmapDrawable</span><br></pre></td></tr></table></figure>
<h3 id="三者的互动关系很简单，DraweeView-把获得的-Event-转发给-Controller，然后-Controller-根据-Event-来决定是否需要显示和隐藏-（包括动画）图像，而这些图像都存储在-Hierarchy-中，最后-DraweeView-绘制时直接通过-getTopLevelDrawable-就可以获取需要显示的图像。"><a href="#三者的互动关系很简单，DraweeView-把获得的-Event-转发给-Controller，然后-Controller-根据-Event-来决定是否需要显示和隐藏-（包括动画）图像，而这些图像都存储在-Hierarchy-中，最后-DraweeView-绘制时直接通过-getTopLevelDrawable-就可以获取需要显示的图像。" class="headerlink" title="三者的互动关系很简单，DraweeView 把获得的 Event 转发给 Controller，然后 Controller 根据 Event 来决定是否需要显示和隐藏 （包括动画）图像，而这些图像都存储在 Hierarchy 中，最后 DraweeView 绘制时直接通过 getTopLevelDrawable 就可以获取需要显示的图像。"></a>三者的互动关系很简单，DraweeView 把获得的 Event 转发给 Controller，然后 Controller 根据 Event 来决定是否需要显示和隐藏 （包括动画）图像，而这些图像都存储在 Hierarchy 中，最后 DraweeView 绘制时直接通过 getTopLevelDrawable 就可以获取需要显示的图像。</h3><p><img src="/img/fresco_relation_schema.png" alt="关系图"></p>
<h3 id="需要注意的是，虽然现在最新的代码中，DraweeView-还是继承自-ImageView，但是以后会直接继承-View，所以我们用-DraweeView-时，尽量不要使用-ImageView-的API，例如-setImageXxx、setScaleType，注释里也写得很清楚。"><a href="#需要注意的是，虽然现在最新的代码中，DraweeView-还是继承自-ImageView，但是以后会直接继承-View，所以我们用-DraweeView-时，尽量不要使用-ImageView-的API，例如-setImageXxx、setScaleType，注释里也写得很清楚。" class="headerlink" title="需要注意的是，虽然现在最新的代码中，DraweeView 还是继承自 ImageView，但是以后会直接继承 View，所以我们用 DraweeView 时，尽量不要使用 ImageView 的API，例如 setImageXxx、setScaleType，注释里也写得很清楚。"></a>需要注意的是，虽然现在最新的代码中，DraweeView 还是继承自 ImageView，但是以后会直接继承 View，所以我们用 DraweeView 时，尽量不要使用 ImageView 的API，例如 setImageXxx、setScaleType，注释里也写得很清楚。</h3><h3 id="7、Fresco框架的ImagePipeline设计图"><a href="#7、Fresco框架的ImagePipeline设计图" class="headerlink" title="7、Fresco框架的ImagePipeline设计图"></a>7、Fresco框架的ImagePipeline设计图</h3><p><img src="/img/fresco_pipeline_plan.png" alt="设计图"></p>
<h3 id="从设计图中可以看出，UIThread只做图片的显示和从内存缓存中加载图片这两件事，而其它事情如：图片的Decode、内存缓存的写、硬盘缓存的IO-操作、网络操作等都用非UIThread来处理了，这使得UIThread专注界面的显示，而其它工作由其它线程完成，使UI更加流畅。"><a href="#从设计图中可以看出，UIThread只做图片的显示和从内存缓存中加载图片这两件事，而其它事情如：图片的Decode、内存缓存的写、硬盘缓存的IO-操作、网络操作等都用非UIThread来处理了，这使得UIThread专注界面的显示，而其它工作由其它线程完成，使UI更加流畅。" class="headerlink" title="从设计图中可以看出，UIThread只做图片的显示和从内存缓存中加载图片这两件事，而其它事情如：图片的Decode、内存缓存的写、硬盘缓存的IO 操作、网络操作等都用非UIThread来处理了，这使得UIThread专注界面的显示，而其它工作由其它线程完成，使UI更加流畅。"></a>从设计图中可以看出，UIThread只做图片的显示和从内存缓存中加载图片这两件事，而其它事情如：图片的Decode、内存缓存的写、硬盘缓存的IO 操作、网络操作等都用非UIThread来处理了，这使得UIThread专注界面的显示，而其它工作由其它线程完成，使UI更加流畅。</h3><h3 id="6、使用了三级缓存：Bitmap缓存-未解码图片缓存-硬盘缓存。"><a href="#6、使用了三级缓存：Bitmap缓存-未解码图片缓存-硬盘缓存。" class="headerlink" title="6、使用了三级缓存：Bitmap缓存+未解码图片缓存+硬盘缓存。"></a>6、使用了三级缓存：Bitmap缓存+未解码图片缓存+硬盘缓存。</h3><h3 id="其中前两个就是内存缓存，Bitmap缓存根据系统版本不同放在了不同内存区域中，而未解码图片的缓存只在堆内存中，Fresco分了两步做内存缓存，这-样做加快图片的加载速度，Fresco的加载图片的流程为：查找Bitmap缓存中是否存在，存在-则直接返回Bitmap直接使用，不存在则查找未解码图片的缓存，如果存在则进行Decode成Bitmap然后直接使用并加入Bitmap缓存中，如果-未解码图片缓存中查找不到，则进行硬盘缓存的检查，如有，则进行IO、转化、解码等一系列操作，最后成Bitmap供我们直接使用，并把未解码-（Encode）的图片加入未解码图片缓存，把Bitmap加入Bitmap缓存中，如硬盘缓存中没有，则进行Network操作下载图片，然后加入到各-个缓存中。"><a href="#其中前两个就是内存缓存，Bitmap缓存根据系统版本不同放在了不同内存区域中，而未解码图片的缓存只在堆内存中，Fresco分了两步做内存缓存，这-样做加快图片的加载速度，Fresco的加载图片的流程为：查找Bitmap缓存中是否存在，存在-则直接返回Bitmap直接使用，不存在则查找未解码图片的缓存，如果存在则进行Decode成Bitmap然后直接使用并加入Bitmap缓存中，如果-未解码图片缓存中查找不到，则进行硬盘缓存的检查，如有，则进行IO、转化、解码等一系列操作，最后成Bitmap供我们直接使用，并把未解码-（Encode）的图片加入未解码图片缓存，把Bitmap加入Bitmap缓存中，如硬盘缓存中没有，则进行Network操作下载图片，然后加入到各-个缓存中。" class="headerlink" title="其中前两个就是内存缓存，Bitmap缓存根据系统版本不同放在了不同内存区域中，而未解码图片的缓存只在堆内存中，Fresco分了两步做内存缓存，这 样做加快图片的加载速度，Fresco的加载图片的流程为：查找Bitmap缓存中是否存在，存在 则直接返回Bitmap直接使用，不存在则查找未解码图片的缓存，如果存在则进行Decode成Bitmap然后直接使用并加入Bitmap缓存中，如果 未解码图片缓存中查找不到，则进行硬盘缓存的检查，如有，则进行IO、转化、解码等一系列操作，最后成Bitmap供我们直接使用，并把未解码 （Encode）的图片加入未解码图片缓存，把Bitmap加入Bitmap缓存中，如硬盘缓存中没有，则进行Network操作下载图片，然后加入到各 个缓存中。"></a>其中前两个就是内存缓存，Bitmap缓存根据系统版本不同放在了不同内存区域中，而未解码图片的缓存只在堆内存中，Fresco分了两步做内存缓存，这 样做加快图片的加载速度，Fresco的加载图片的流程为：查找Bitmap缓存中是否存在，存在 则直接返回Bitmap直接使用，不存在则查找未解码图片的缓存，如果存在则进行Decode成Bitmap然后直接使用并加入Bitmap缓存中，如果 未解码图片缓存中查找不到，则进行硬盘缓存的检查，如有，则进行IO、转化、解码等一系列操作，最后成Bitmap供我们直接使用，并把未解码 （Encode）的图片加入未解码图片缓存，把Bitmap加入Bitmap缓存中，如硬盘缓存中没有，则进行Network操作下载图片，然后加入到各 个缓存中。</h3><h3 id="既然Fresco使用了三级缓存，而有两级是内存缓存，所以当我们的App在后台时或者在内存低的情况下在onLowMemory-方法中，我们应该手动清除应用的内存缓存，我们可以使用下面的方式："><a href="#既然Fresco使用了三级缓存，而有两级是内存缓存，所以当我们的App在后台时或者在内存低的情况下在onLowMemory-方法中，我们应该手动清除应用的内存缓存，我们可以使用下面的方式：" class="headerlink" title="既然Fresco使用了三级缓存，而有两级是内存缓存，所以当我们的App在后台时或者在内存低的情况下在onLowMemory()方法中，我们应该手动清除应用的内存缓存，我们可以使用下面的方式："></a>既然Fresco使用了三级缓存，而有两级是内存缓存，所以当我们的App在后台时或者在内存低的情况下在onLowMemory()方法中，我们应该手动清除应用的内存缓存，我们可以使用下面的方式：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ImagePipeline imagePipeline = Fresco.getImagePipeline();</span><br><span class="line">//清空内存缓存（包括Bitmap缓存和未解码图片的缓存）</span><br><span class="line">imagePipeline.clearMemoryCaches();</span><br><span class="line">//清空硬盘缓存，一般在设置界面供用户手动清理</span><br><span class="line">imagePipeline.clearDiskCaches();</span><br><span class="line">//同时清理内存缓存和硬盘缓存</span><br><span class="line">imagePipeline.clearCaches();</span><br></pre></td></tr></table></figure>
<h2 id="了解一下BItmap的处理："><a href="#了解一下BItmap的处理：" class="headerlink" title="了解一下BItmap的处理："></a>了解一下BItmap的处理：</h2><h3 id="Android在各个版本上处理Bitmap的不同，在Android-3-0以后，android的bitmap的数据也存储在java-heap中，所以你不用太关心内存，内存会由java虚拟机回收。Android-3-0以前，由于google觉得虚拟机性能还不够，所以bitmap的内存数据是放在Ashmen里的，需要开发者显示调用-Bitmap-recycle-来回收内存（其实不调用也没事，系统也能给你处理好，比如进程死了）。"><a href="#Android在各个版本上处理Bitmap的不同，在Android-3-0以后，android的bitmap的数据也存储在java-heap中，所以你不用太关心内存，内存会由java虚拟机回收。Android-3-0以前，由于google觉得虚拟机性能还不够，所以bitmap的内存数据是放在Ashmen里的，需要开发者显示调用-Bitmap-recycle-来回收内存（其实不调用也没事，系统也能给你处理好，比如进程死了）。" class="headerlink" title="Android在各个版本上处理Bitmap的不同，在Android 3.0以后，android的bitmap的数据也存储在java heap中，所以你不用太关心内存，内存会由java虚拟机回收。Android 3.0以前，由于google觉得虚拟机性能还不够，所以bitmap的内存数据是放在Ashmen里的，需要开发者显示调用 Bitmap.recycle()来回收内存（其实不调用也没事，系统也能给你处理好，比如进程死了）。"></a>Android在各个版本上处理Bitmap的不同，在Android 3.0以后，android的bitmap的数据也存储在java heap中，所以你不用太关心内存，内存会由java虚拟机回收。Android 3.0以前，由于google觉得虚拟机性能还不够，所以bitmap的内存数据是放在Ashmen里的，需要开发者显示调用 Bitmap.recycle()来回收内存（其实不调用也没事，系统也能给你处理好，比如进程死了）。</h3><h3 id="由于Bitmap是内存大户，所以Google是意识到这个问题的为了减低内存的分配，减少GC，Google在Android3-0-以后也提供了一个特别有用的特性BitmapFactory-Options-inBitamp-这个特性呢，能让图片在同一块内存区域上解码而达到重复利用这块内存，Android-4-4之前呢要求两张图片的大小必须一样，4-4之后呢只要保证内存比需要解码的图片大就可以了。所以我们的应用只在4-4上跑，是可以做到高效的内存管理的。"><a href="#由于Bitmap是内存大户，所以Google是意识到这个问题的为了减低内存的分配，减少GC，Google在Android3-0-以后也提供了一个特别有用的特性BitmapFactory-Options-inBitamp-这个特性呢，能让图片在同一块内存区域上解码而达到重复利用这块内存，Android-4-4之前呢要求两张图片的大小必须一样，4-4之后呢只要保证内存比需要解码的图片大就可以了。所以我们的应用只在4-4上跑，是可以做到高效的内存管理的。" class="headerlink" title="由于Bitmap是内存大户，所以Google是意识到这个问题的为了减低内存的分配，减少GC，Google在Android3.0 以后也提供了一个特别有用的特性BitmapFactory.Options.inBitamp,这个特性呢，能让图片在同一块内存区域上解码而达到重复利用这块内存，Android 4.4之前呢要求两张图片的大小必须一样，4.4之后呢只要保证内存比需要解码的图片大就可以了。所以我们的应用只在4.4上跑，是可以做到高效的内存管理的。"></a>由于Bitmap是内存大户，所以Google是意识到这个问题的为了减低内存的分配，减少GC，Google在Android3.0 以后也提供了一个特别有用的特性BitmapFactory.Options.inBitamp,这个特性呢，能让图片在同一块内存区域上解码而达到重复利用这块内存，Android 4.4之前呢要求两张图片的大小必须一样，4.4之后呢只要保证内存比需要解码的图片大就可以了。所以我们的应用只在4.4上跑，是可以做到高效的内存管理的。</h3><h2 id="以compile-‘com-facebook-fresco-fresco-0-8-1’的方式引用，比较apk的大小："><a href="#以compile-‘com-facebook-fresco-fresco-0-8-1’的方式引用，比较apk的大小：" class="headerlink" title="以compile ‘com.facebook.fresco:fresco:0.8.1’的方式引用，比较apk的大小："></a>以compile ‘com.facebook.fresco:fresco:0.8.1’的方式引用，比较apk的大小：</h2><h3 id="1、打包环境Jenkins，版本分支为6-5-4-0；"><a href="#1、打包环境Jenkins，版本分支为6-5-4-0；" class="headerlink" title="1、打包环境Jenkins，版本分支为6.5.4.0；"></a>1、打包环境Jenkins，版本分支为6.5.4.0；</h3><h3 id="2、在不生成arm64-v8a、armeabi-v7a、x86、x86-64的-so的文件库，只生成armeabi库文件的前提下（因fresco会-生成前四个库文件）；"><a href="#2、在不生成arm64-v8a、armeabi-v7a、x86、x86-64的-so的文件库，只生成armeabi库文件的前提下（因fresco会-生成前四个库文件）；" class="headerlink" title="2、在不生成arm64-v8a、armeabi-v7a、x86、x86_64的.so的文件库，只生成armeabi库文件的前提下（因fresco会                生成前四个库文件）；"></a>2、在不生成arm64-v8a、armeabi-v7a、x86、x86_64的.so的文件库，只生成armeabi库文件的前提下（因fresco会                生成前四个库文件）；</h3><h3 id="3、原工程的apk大小为25-2MB，引入后的apk大小为26-5MB，增加1-3MB；"><a href="#3、原工程的apk大小为25-2MB，引入后的apk大小为26-5MB，增加1-3MB；" class="headerlink" title="3、原工程的apk大小为25.2MB，引入后的apk大小为26.5MB，增加1.3MB；"></a>3、原工程的apk大小为25.2MB，引入后的apk大小为26.5MB，增加1.3MB；</h3><h2 id="比较内存占用，测试机华为荣耀6plus（PE-L10）、运行内存3GB，系统版本android4-4-2，测试页面首页，app版本6-5-4-0："><a href="#比较内存占用，测试机华为荣耀6plus（PE-L10）、运行内存3GB，系统版本android4-4-2，测试页面首页，app版本6-5-4-0：" class="headerlink" title="比较内存占用，测试机华为荣耀6plus（PE-L10）、运行内存3GB，系统版本android4.4.2，测试页面首页，app版本6.5.4.0："></a>比较内存占用，测试机华为荣耀6plus（PE-L10）、运行内存3GB，系统版本android4.4.2，测试页面首页，app版本6.5.4.0：</h2><h3 id="引入前"><a href="#引入前" class="headerlink" title="引入前"></a>引入前</h3><p><img src="/img/fresco_test_traceview1.png" alt="traceview1"><br><img src="/img/fresco_test_meminfo1.png" alt="meminfo1"></p>
<h3 id="引入后"><a href="#引入后" class="headerlink" title="引入后"></a>引入后</h3><p><img src="/img/fresco_test_traceview2.png" alt="traceview1"><br><img src="/img/fresco_test_meminfo2.png" alt="meminfo1"></p>
<h3 id="2、流畅度体验，目前和原方案一样，还是存在首次滑动卡顿的情况："><a href="#2、流畅度体验，目前和原方案一样，还是存在首次滑动卡顿的情况：" class="headerlink" title="2、流畅度体验，目前和原方案一样，还是存在首次滑动卡顿的情况："></a>2、流畅度体验，目前和原方案一样，还是存在首次滑动卡顿的情况：</h3><h3 id="引入前-引入后"><a href="#引入前-引入后" class="headerlink" title="引入前                                                                                  引入后"></a>引入前                                                                                  引入后</h3><h2 id="使用详情链接"><a href="#使用详情链接" class="headerlink" title="使用详情链接"></a>使用详情<a href="http://www.fresco-cn.org/docs/index.html#_" target="_blank" rel="external">链接</a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/27/引入Fresco前调研报告/" data-id="cimapwsyb0001rss8jpbo4ze7" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/hello-world/" class="article-date">
  <time datetime="2016-03-18T08:12:37.594Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/18/hello-world/" data-id="cimapwsy20000rss828pg0hy2" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/27/引入Fresco前调研报告/">引入Fresco前的调研报告</a>
          </li>
        
          <li>
            <a href="/2016/03/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Jason Zhang<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>